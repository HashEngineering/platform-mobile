use platform_value::types::identifier::{Identifier, IdentifierBytes32};
use dpp::identity::identity::Identity;
use dpp::errors::protocol_error::ProtocolError;
use platform_version::version::PlatformVersion;
use dpp::document::{Document, DocumentV0Getters};
use rs_sdk::platform::{DocumentQuery, Fetch, FetchMany};
use dpp::prelude::{DataContract};

#[ferment_macro::export]
pub fn fetch_identity(identifier: Identifier) -> Identity {
    Identity::create_basic_identity(identifier.into(), PlatformVersion::latest()).expect("failed")

    // Result::Err(ProtocolError::IdentifierError("error with id".into()))
}

#[ferment_macro::export]
pub fn fetch_identity2(identifier: Identifier) -> Identity {
    identity_read(&identifier).expect("not found")
}
//#[ferment_macro::export]
pub struct FermentError { error_message: String }
#[ferment_macro::export]
pub fn fetch_identity3(identifier: Identifier) -> Result<Identity, String> {
    match identity_read(&identifier) {
        Ok(identity) => Ok(identity),
        Err(err) => Err(err.to_string())
    }
}

#[ferment_macro::export]
pub fn get_document()-> Identifier {
    let it = document_read();
    match it {
        Document::V0(docV0) => docV0.id,
        _ => Identifier::default()
    }
}


use rs_dapi_client::AddressList;
//use serde::Deserialize;
use std::{path::PathBuf, str::FromStr, sync::Arc};

/// Existing document ID
///
// TODO: this is copy-paste from drive-abci `packages/rs-sdk/tests/fetch/main.rs` where it's private,
// consider defining it in `data-contracts` crate
const DPNS_DASH_TLD_DOCUMENT_ID: [u8; 32] = [
    215, 242, 197, 63, 70, 169, 23, 171, 110, 91, 57, 162, 215, 188, 38, 11, 100, 146, 137, 69, 55,
    68, 209, 224, 212, 242, 106, 141, 142, 255, 55, 207,
];

const DPNS_DATACONTRACT_ID: [u8; 32] = [
    230, 104, 198, 89, 175, 102, 174, 225, 231, 44, 24, 109, 222, 123, 91, 126, 10, 29, 113, 42, 9,
    196, 13, 87, 33, 246, 34, 191, 83, 197, 49, 85,
];

#[derive(Debug)]
/// Configuration for dash-platform-sdk.
///
/// Content of this configuration is loaded from environment variables or `${CARGO_MANIFEST_DIR}/.env` file
/// when the [Config::new()] is called.
/// Variable names in the enviroment and `.env` file must be prefixed with [RS_SDK_](Config::CONFIG_PREFIX)
/// and written as SCREAMING_SNAKE_CASE (e.g. `RS_SDK_PLATFORM_HOST`).
pub struct Config {
    /// Hostname of the Dash Platform node to connect to

    pub platform_host: String,
    /// Port of the Dash Platform node grpc interface

    pub platform_port: u16,
    /// Port of the Dash Core RPC interface running on the Dash Platform node
    pub core_ip: String,

    pub core_port: u16,
    /// Username for Dash Core RPC interface

    pub core_user: String,
    /// Password for Dash Core RPC interface

    pub core_password: String,
    /// When true, use SSL for the Dash Platform node grpc interface

    pub platform_ssl: bool,

    /// Directory where all generated test vectors will be saved.
    ///
    /// See [SdkBuilder::with_dump_dir()](crate::SdkBuilder::with_dump_dir()) for more details.
    pub dump_dir: PathBuf,

    // IDs of some objects generated by the testnet
    /// ID of existing identity.
    ///
    /// Format: Base58
    pub existing_identity_id: Identifier,
    /// ID of existing data contract.
    ///
    /// Format: Base58
    pub existing_data_contract_id: Identifier,
    /// Name of document type defined for [`existing_data_contract_id`](Config::existing_data_contract_id).
    pub existing_document_type_name: String,
    /// ID of document of the type [`existing_document_type_name`](Config::existing_document_type_name)
    /// in [`existing_data_contract_id`](Config::existing_data_contract_id).
    pub existing_document_id: Identifier,
}

impl Config {
    /// Prefix of configuration options in the environment variables and `.env` file.
    pub const CONFIG_PREFIX: &'static str = "RS_SDK_";
    /// Load configuration from operating system environment variables and `.env` file.
    ///
    /// Create new [Config] with data from environment variables and `${CARGO_MANIFEST_DIR}/tests/.env` file.
    /// Variable names in the environment and `.env` file must be converted to SCREAMING_SNAKE_CASE and
    /// prefixed with [RS_SDK_](Config::CONFIG_PREFIX).
    pub fn new() -> Self {
        // load config from .env file, ignore errors

        let path: String = env!("CARGO_MANIFEST_DIR").to_owned() + "/tests/.env";
        // if let Err(err) = dotenvy::from_path(&path) {
        //      //tracing::warn!(path, ?err, "failed to load config file");
        // }

        // let config: Self = envy::prefixed(Self::CONFIG_PREFIX)
        //     .from_env()
        //     .expect("configuration error");
        let config = Config {
            platform_host: "35.165.50.126".to_string(),
            platform_port: 1443,
            core_ip: "127.0.0.1".to_string(),
            core_port: 19998,
            core_user: "left".to_string(),
            core_password: "right".to_string(),
            platform_ssl: true,
            dump_dir: Default::default(),
            existing_identity_id: Identifier(IdentifierBytes32(DPNS_DASH_TLD_DOCUMENT_ID)),
            existing_data_contract_id: Identifier(IdentifierBytes32(DPNS_DATACONTRACT_ID)),
            existing_document_type_name: "domain".to_string(),
            existing_document_id: Identifier(IdentifierBytes32(DPNS_DASH_TLD_DOCUMENT_ID)),
        };

        if config.is_empty() {
            tracing::warn!(path, ?config, "some config fields are empty");
            #[cfg(not(feature = "offline-testing"))]
            panic!("invalid configuration")
        }

        config
    }

    /// Check if credentials of the config are empty.
    ///
    /// Checks if fields [platform_host](Config::platform_host), [platform_port](Config::platform_port),
    /// [core_port](Config::core_port), [core_user](Config::core_user) and [core_password](Config::core_password)
    /// are not empty.
    ///
    /// Other fields are ignored.
    pub fn is_empty(&self) -> bool {
        self.core_user.is_empty()
            || self.core_password.is_empty()
            || self.platform_host.is_empty()
            || self.platform_port == 0
            || self.core_port == 0
    }

    #[allow(unused)]
    /// Create list of Platform addresses from the configuration
    pub fn address_list(&self) -> AddressList {
        let scheme = match self.platform_ssl {
            true => "https",
            false => "http",
        };

        let address: String = format!("{}://{}:{}", scheme, self.platform_host, self.platform_port);

        AddressList::from_iter(vec![http::Uri::from_str(&address).expect("valid uri")])
    }

    /// Create new SDK instance
    ///
    /// Depending on the feature flags, it will connect to the configured platform node or mock API.
    ///
    /// ## Feature flags
    ///
    /// * `offline-testing` is not set - connect to the platform and generate
    /// new test vectors during execution
    /// * `offline-testing` is set - use mock implementation and
    /// load existing test vectors from disk
    pub async fn setup_api(&self) -> Arc<rs_sdk::Sdk> {
        // offline testing takes precedence over network testing
        //#[cfg(all(feature = "network-testing", not(feature = "offline-testing")))]
            let sdk = {
            // Dump all traffic to disk
            let builder = rs_sdk::SdkBuilder::new(self.address_list()).with_core(
                &self.core_ip,
                self.core_port,
                &self.core_user,
                &self.core_password,
            );

            #[cfg(feature = "generate-test-vectors")]
                let builder = builder.with_dump_dir(&self.dump_dir);

            builder.build().expect("cannot initialize api")
        };

        sdk
    }

    fn default_identity_id() -> Identifier {
        data_contracts::dpns_contract::OWNER_ID_BYTES.into()
    }

    fn default_data_contract_id() -> Identifier {
        data_contracts::dpns_contract::ID_BYTES.into()
    }

    fn default_document_type_name() -> String {
        "domain".to_string()
    }
    fn default_document_id() -> Identifier {
        DPNS_DASH_TLD_DOCUMENT_ID.into()
    }

    fn default_dump_dir() -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("tests")
            .join("vectors")
    }
}

async fn test_identity_read() {
    setup_logs();

    use dpp::identity::accessors::IdentityGettersV0;
    let cfg = Config::new();
    let id: dpp::prelude::Identifier = cfg.existing_identity_id;

    let sdk = cfg.setup_api().await;

    let identity = Identity::fetch(&sdk, id)
        .await
        .expect("fetch identity")
        .expect("found identity");

    assert_eq!(identity.id(), id);
}
 fn document_read() -> Document {
    setup_logs();

    let rt = tokio::runtime::Runtime::new().expect("Failed to create a runtime");

    // Execute the async block using the Tokio runtime
    rt.block_on(async {
        let cfg = Config::new();
        let sdk = cfg.setup_api().await;

        let data_contract_id = cfg.existing_data_contract_id;
        tracing::warn!("using existing data contract id and fetching...");
        let contract = Arc::new(
            DataContract::fetch(&sdk, data_contract_id)
                .await
                .expect("fetch data contract")
                .expect("data contract not found"),
        );

        tracing::warn!("fetching many...");
        // Fetch multiple documents so that we get document ID
        let all_docs_query =
            DocumentQuery::new(Arc::clone(&contract), &cfg.existing_document_type_name)
                .expect("create SdkDocumentQuery");
        let first_doc = Document::fetch_many(&sdk, all_docs_query)
            .await
            .expect("fetch many documents")
            .pop_first()
            .expect("first item must exist")
            .1
            .expect("document must exist");

        // Now query for individual document
        let query = DocumentQuery::new(contract, &cfg.existing_document_type_name)
            .expect("create SdkDocumentQuery")
            .with_document_id(&first_doc.id());

        let doc = Document::fetch(&sdk, query)
            .await
            .expect("fetch document")
            .expect("document must be found");

        //assert_eq!(first_doc, doc);

        doc
    })
}

fn identity_read(id: &Identifier) -> Result<Identity, ProtocolError> {
    setup_logs();
    // Create a new Tokio runtime
    let rt = tokio::runtime::Runtime::new().expect("Failed to create a runtime");

    // Execute the async block using the Tokio runtime
    rt.block_on(async {
        // Your async code here
        let cfg = Config::new();
        let id: dpp::prelude::Identifier = id.clone();

        let sdk = cfg.setup_api().await;

        let identity_result = Identity::fetch(&sdk, id).await;

        match identity_result {
            Ok(Some(identity)) => {
                // If you have an assertion here, note that assertions in async blocks will panic in the async context
                // assert_eq!(identity.id(), id);
                // Instead of an assertion, you might return an Ok or Err based on your logic
                Ok(identity)
            },
            Ok(None) => Err(ProtocolError::IdentifierError("Identity not found".to_string())), // Placeholder for actual error handling
            Err(e) => Err(ProtocolError::IdentifierError("Identifier not found: failure".to_string())), // Convert your error accordingly
        }
    })
}

pub fn setup_logs() {
    tracing_subscriber::fmt::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::new(
            "info,rs_sdk=trace,h2=info",
        ))
        .pretty()
        .with_ansi(false)
        .with_writer(std::io::stdout)
        .try_init()
        .ok();
}